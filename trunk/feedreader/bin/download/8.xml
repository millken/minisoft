<?xml version="1.0" encoding="GBK" ?>
<rss version="2.0" xmlns:slash="http://purl.org/rss/1.0/modules/slash/" xmlns:dcterms="http://purl.org/dc/terms/">
 <channel>
  	  <title><![CDATA[Atry]]></title>
	  <link>http://www.ac.net.blog.163.com</link>
	  <description><![CDATA[ ]]></description>
	  <language>zh-CN</language>
	  <pubDate>Sat, 6 Mar 2010 16:36:55 +0800</pubDate>
	  <lastBuildDate>Sat, 6 Mar 2010 16:36:55 +0800</lastBuildDate>
	  <docs>http://blogs.law.harvard.edu/tech/rss</docs>
	  <generator><![CDATA[NetEase Space]]></generator>
	  <managingEditor><![CDATA[www.ac.net]]></managingEditor>
	  <webMaster><![CDATA[Atry]]></webMaster>
		  <ttl>120</ttl>
	  <image>
	  	<title><![CDATA[Atry]]></title>
	  	<url>http://ava.bimg.126.net/photo/lfYP8zYdeGb74Ey-0m5hjw==/177892185281420447.jpg</url>
	  	<link>http://www.ac.net.blog.163.com</link>
	  </image>
  <item>
  	<title><![CDATA[对星际争霸 2 ZVP 的兵种相克的一点认识]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056201026115815877</link>
    <description><![CDATA[<div>最近打了几盘星际 2，基本上都是选的虫族。面对神族玩家我的胜率还可以。以下是一些经验。<p>初期地面兵种方面，虫族的蟑螂非常强大。我想说五个字，蟑螂亚克西。蟑螂只要 A 过去，可以轻松扫平神族除了巨像以外的所有兵种。所以神族打虫族一定会攀科技，要么出空军，要么出巨像。巨像也是一个 bug 兵种，虫族雷兽以外的任何兵种都会被巨像完克。</p><p>问题在于，巨像和空军都是高级兵种，初期如果蟑螂成形，可以抢这个时机，先推一波。如果没推下来，接下来再转空中部队还来得及。</p><p>说到空军就非常有趣，神族可能打其他种族的时候会比较喜欢造虚空舰，获得制空权之后拆建筑很爽。可是打虫族的时候神族往往喜欢造凤凰战机，一方面是因为凤凰战机克制飞龙，另一方面是因为虫族的领主是飞在天上的，一旦神族掌握了制空权，屠杀领主就足够赚了，非常威猛。</p><p>一代虫族的空对空的主力兵种是&nbsp;Devourer （吞噬者），除了打 &nbsp;Big Game Hunter ，我还没见人造过，因为这玩意儿科技要求太高了，要三本才能出，所以那时候往往就造点自杀飞机配合飞龙得了。可是到了星际2，暴雪把吞噬者改了个名，叫做腐蚀者，再把科技提前到二本，有飞龙塔就能出，那就具备了实战价值。腐蚀者就是专门对付凤凰战机的。干掉凤凰战机之后，飞龙再上，干光农民，对方就 GG 了。</p><p>总结一下战术，就是初期蟑螂推一波。这段时间注意攒气。在对方转型以后自己也转型，飞龙混合腐蚀者夺取制空权，胜利。</p></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056201026115815877</comments>
    <slash:comments>2</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056201026115815877</guid>
    <pubDate>Sat, 6 Mar 2010 11:58:15 +0800</pubDate>
    <dcterms:modified>2010-03-06T16:35:59+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[Protocol Buffers 的 ActionScript 3 编译器]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056201001665314467</link>
    <description><![CDATA[<div><P>现有的两个 protobuf 的 ActionScript 3 编译器都糟糕透顶，不支持 packed ，不支持内部类，不支持 enum ，对浮点的支持还有 bug。最恶心的是，居然在构造函数中调用 registerField 然后用动态属性的方式来进行序列化。这样做性能恶劣就不提了，居然还为每个 message 实例都生成了一大堆描述对象，浪费内存。 </P>
<P>要在他们的基础上把这坨渣改好，实在超出了在下的能力范围。我的能力范围内，唯一能做的就是重新写一个。可以在这里下载到：<A href="http://protoc-gen-as3.googlecode.com/" target=_blank>http://protoc-gen-as3.googlecode.com/</A><BR></P>
<P>和 <A href="http://protobuf-actionscript3.googlecode.com/" rel=nofollow target=_blank>http://protobuf-actionscript3.googlecode.com/</A> 比较而言，我提供的 API 接口要比它简单，而且大多都是 ActionScript 3 原生的写法。但我提供的功能却比它多，支持 packed ，支持 enum ，还能保留 proto 文件中的原始层次结构。目前不支持的功能只有 group 和 service。 group 是已经 deprecated 的特性，而 service 是用来定义 RPC 的，大多数人都很少需要用到。</P></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056201001665314467</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056201001665314467</guid>
    <pubDate>Sat, 16 Jan 2010 18:53:14 +0800</pubDate>
    <dcterms:modified>2010-01-20T19:25:21+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[ActionScript 3 的 .ctags 配置文件]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009112453949669</link>
    <description><![CDATA[<div><P>虽然网上能找到别人写的 ActionScript 3 的 .ctags 配置文件，但是不好用。我写的这个 .ctags 配置文件包括了属性、变量、常量、函数、类。除了类以外，会被记下的符号必须至少有一个修饰符（比如 final、private、public、protected），这样可以避免生成的 tags 文件中出现局部变量。</P>
<FIELDSET><LEGEND>.ctags</LEGEND><PRE>--langdef=actionscript<BR>--langmap=actionscript:.as<BR>--regex-actionscript=/^[ \t]*([a-z]+[ \t]+)+function[ \t]+([A-Za-z0-9_]+)[ \t]*\(/\2/f, function, functions/<BR>--regex-actionscript=/^[ \t]*([a-z]+[ \t]+)+function[ \t]+(set|get)[ \t]+([A-Za-z0-9_]+)[ \t]*\(/\3/p,property, properties/ <BR>--regex-actionscript=/^[ \t]*([a-z]+[ \t]+)+var[ \t]+([A-Za-z0-9_]+)/\2/v,variable, variables/ <BR>--regex-actionscript=/^[ \t]*([a-z]+[ \t]+)+const[ \t]+([A-Za-z0-9_]+)/\2/c,constant, constants/ <BR>--regex-actionscript=/^[ \t]*([a-z]+[ \t]+)*class[ \t]+([A-Za-z0-9_]+)/\2/c,class, classes/ </PRE></FIELDSET>需要在 vim&nbsp;中使用代码提示功能的话，先把本文件保存到 ~/.ctags ，然后运行 ctags -R xxx/src，这样就会生成一个 tags 文件，接下来只要 vim 在当前目录能找到这个文件，你就可以用 CTRL+] 查找代码，可以用 CTRL+N 进行代码补全了。</div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009112453949669</comments>
    <slash:comments>2</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009112453949669</guid>
    <pubDate>Thu, 24 Dec 2009 17:39:49 +0800</pubDate>
    <dcterms:modified>2010-01-20T19:34:27+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[手机待机时间]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009112110292286</link>
    <description><![CDATA[<div><P>大概一个多月以前在淘宝买了一个手机，Samsung Galaxy，是 Android 的系统，用着感觉挺好。 </P>
<P>可是，用了一两天之后就发现了一个致命问题，这个手机的待机时间很短，大概七八个小时就没电了。不管我用手机用得多还是用得少，都只能用七八个小时。这样一来，我早上充好电，到了下午就没电了，杯具啊。 </P>
<P>为了解决这个悲剧，我跟卖家进行了交涉，卖家同意我把电池寄回去给我换一块。换了新电池以后，杯具变成了餐具，现在只能用五六个小时了。我再跟卖家交涉，结果双方都闹得不是很愉快，卖家就不理我了。这个手机又已经买了超过 14 天了，淘宝也不接受投诉了。没办法，我只好凑合着用，每天上班的时候带一根数据线，到了公司就把手机连到电脑上，让电脑给它充电。 </P>
<P>上周五我回家的时候忘了把手机从电脑上拔下来，是云风第二天帮我把手机带给我的。结果这个周末手机电池的池品爆发了。昨天早上充完电到现在已经一天一夜了，手机还是满格电。</P>
<P>最后发现，这是因为平时上班或在家都连着 wifi，而周末在上海的时候，没有 wifi 信号，所以省电了。</P></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009112110292286</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009112110292286</guid>
    <pubDate>Mon, 21 Dec 2009 10:29:22 +0800</pubDate>
    <dcterms:modified>2009-12-25T09:14:33+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[程序设计的“实质重于形式”原则]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200991831813820</link>
    <description><![CDATA[<div><P>会计有一个<STRONG>实质重于形式</STRONG>原则，指企业应当按照交易或事项的经济实质进行会计核算，而不应当仅仅按照它们的法律形式作为会计核算的依据。我借用这个术语到程序设计领域，意思是：<STRONG>设计程序时，应当按照程序员使用时需要知道的知识（实质）来判断依赖关系及程度，而不应当按照机器编译或者执行代码时的引用关系（形式）</STRONG>。 
</P><P>例如，程序员甲和乙各写了一坨代码，甲常常问乙乙的代码怎么用，而乙每天闷头些代码，既不去看甲写的代码，也不主动去找甲。那么，不论甲乙二人的代码分别用哪一种语言写的，也不论甲乙二人谁调用了谁的函数，我们一定可以肯定甲的代码实质上单向依赖于乙的代码。</P>
<P>注意，<Q>实质</Q>是指程序员需要知道的知识，而不代表确实知道的知识。尽管低耦合的模块关系意味着程序员只需要知道很少的知识就可以与另一模块一起工作，但不管怎么说，程序员对同事的代码都是越熟悉越好的。</P>
<P>《设计模式》中的一些模式，只需简单套用就能降低程序的形式耦合度。但是这和降低程序的实质耦合度是两个不同的问题，而后者并不是简单套用模式就能做到的。</P>
<P>例如：某个 Java 代码，原先是用 new XXX 来创建一个对象的，后来改用工厂模式，从 XML 配置文件中读取类名，再用反射来创建这个对象。虽然形式上创建对象的代码不依赖于 XXX 这个类，但实质是否依赖则不一定。假如 XML 配置文件的维护者和编写创建代码的人是同一人，并且仍然需要关注 XXX 的行为，那么实质的依赖就仍然存在。</P>
<P>然而，有可能在形式耦合不变的情况下降低实质耦合，比如，某项目在编写模块的测试用例以后，精简了模块的接口，降低了沟通成本，这就是在实质上降低了耦合。</P>
<P><Q>实质重于形式</Q>并不意味着形式必须与实质一致。例如，有一个 C++ 项目，其中的模块 A 依赖于模块 B，但为了编译得更快，模块 A 中并不包含模块 B 的头文件，而采用某种字符串查找的方式访问 B 的功能。这种做法也无可厚非。</P>
<P>两个模块谁依赖于谁应该根据哪一模块变化更频繁来决定。变化频繁的模块依赖于变化不频繁的模块。如果变化频繁的模块是底层模块，那么这种模式被叫做“插件”。</P>
<P>使用接口的模块“实质”依赖于定义了接口的模块，不论使用什么语法。</P>
<P>所以，我们就知道<A href="http://opensource.adobe.com/wiki/display/cairngorm/">Cairngorm</A>、<A href="http://en.wikipedia.org/wiki/Dependency_inversion_principle">DIP</A>和<A href="http://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC">ioC</A>之类的东西只能降低形式耦合，而无助于降低实质耦合。绝大多数情况下，这样写程序都只是在绕圈子，徒增无用代码量而已。</P>
<P>此外，两个模块互不依赖而依赖于抽象接口在实践中往往还是相当于某种单向依赖。因为：</P>
<OL>
<LI>接口总是由开发某个模块的程序员定义的，所以事实上这个接口还是和那个模块绑在了一起。</LI>
<LI>接口两边都变化频繁而接口很稳定的情况在现实世界中非常罕见。</LI></OL>
<P>真正两个模块互不依赖而依赖于抽象接口很罕见，而且，也只有接口两边的模块都存在多个不同实现的时候，才有必要做成这样。</P>
<HR>

<P>其实本文是几个月以前就写下来了的，但是我觉得写得太理论性了，就没有发出来。虽然我的本意是去批判某些不务实的东西，但写得太理论性了文章本身就显得不务实了。写得太理论性的另一个问题是难以理解，可能导致读者理解的意思不是我想要表达的意思。</P></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200991831813820</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200991831813820</guid>
    <pubDate>Fri, 18 Dec 2009 23:26:13 +0800</pubDate>
    <dcterms:modified>2009-12-18T23:26:13+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[银河竞逐心得]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009111531728681</link>
    <description><![CDATA[<div><P>先说一些需要注意的基本情况：</P>
<UL>
<LI>玩银河竞逐的发展策略，有两个主要方向。一个方向是生产消费，另一个方向是军事扩张。这两个方向是有矛盾的。因为生产星球很少是军事星球，所以扩张的时候，要么选择军事星球，要么选择生产星球。而其他的策略，比如开发高科技路线、稀有元素星球路线，和生产消费或者军事扩张是不矛盾的。</LI>
<LI>银河竞逐出了两个扩展包，两个扩展包都在削弱生产消费。 </LI>
<OL>
<LI>第一扩展包增加了许多需求6的开发牌，这些需求6的开发牌配合别的牌加分很多，而往往打军事扩张路线时，打下来的牌会多一些，也就更占优势。第一扩展包还出了一张逆天牌，每个扩张阶段可以扩张两个星球，对军事路线非常有利。不过，第一扩展包的目标牌并未明显偏向军事，大概有一半左右的目标是生产消费路线的。 </LI>
<LI>第二扩展包的目标牌几乎都对军事路线有利，比如3个探索能力、3个叛军、放置8张牌、3个绿字星球。第二扩展包还加入了开战规则，这样一来，走生产消费路线的人如果想偶尔扩展几张低需求的军事牌，就会存在被侵略的风险。 </LI></OL>
<LI>银河竞逐的二人规则和多人规则有所不同。二人游戏可以出两张行动牌，多人游戏只能出一张。所以多人游戏时，自己更难掌控自己的命运，打牌的时候要迁就别人的发展方向。比如，如果好几个人都在往生产消费方向发展，如果自己没有什么生产消费能力，就会很吃亏。 </LI></UL>
<P>银河竞逐中的决策，首先考虑行动牌的选择。选择行动牌的原则是“损人利己”。要估算每张行动牌为对手带来的收益和为自己带来的收益，尽量让对手收益少，自己收益多。估算收益时，通常前期一张手牌与一分等值，后期一分要比一张手牌价值更高。以下是估算收益的一些例子：</P>
<UL>
<LI>双方都没有任何探索能力时，出+1+1探索行动，对方可以得到一张手牌，自己可以得到两张手牌，所以净收益大约是一张手牌（其实要稍微比一张手牌收益大一点）。</LI>
<LI>对方没有生产星球，自己有一个生产星球一个意外收获星球，有足够的一个商品换一分的消费能力。这样的话，出一张生产行动牌，下一轮再出一张VPx2行动牌，两次行动一共获得四分。平均净收益是每个行动两分。</LI></UL>
<P>除此之外，星球的数量也具有潜在的价值，因为很多需求6的开发牌都要求玩家收集某类星球。在你还没有打算好放置合适的开发牌之前，这些星球的价值是潜在的。而在已经确定会放置某个需求6的开发牌之后，星球的价值就可以直接按加分来估算。当然，开发牌的数量也是类似的。</P>
<P>银河竞逐中另一类决策是决定要放置什么牌。放置牌要考虑以下几个方面：</P>
<UL>
<LI>牌的分值，这个通常在最后几个回合考虑得比较多</LI>
<LI>牌的能力，这是中前期考虑的重点。要尽量让放置了牌之后，削减对手有优势的阶段，提高自己有优势的阶段。而双方差距不大的阶段，就没有什么意义。比如：</LI>
<UL>
<LI>对手生产能力很强，可以生产很多商品，而自己生产不出什么商品。这时候如果放置一张生产阶段能摸牌的牌，那么对对手就会施加一些压力了。</LI>
<LI>双方都没有探索阶段能力，对方军事点很高，已经扩张了黄色星球，可以交易换牌，自己生产消费时已有一些补牌能力。这时候如果放置探索阶段能力的牌就没有意义了，因为双方都有自己的优势阶段，没有动机来打探索行动牌，探索能力等于白费。</LI>
<LI>后期游戏即将结束，放置“复制机器人”之类减需求的牌就没什么用了。因为游戏快要结束了，再好的能力也用不了几次，不划算的。</LI></UL></UL>
<P>银河竞逐有电脑版的，可以和 AI 玩（<A href="http://keldon.net/rftg/">http://keldon.net/rftg/</A>），实力还是蛮强的。AI 比较注重实际得分，行动牌出得好，总是能让对手很不舒服。</P></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009111531728681</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009111531728681</guid>
    <pubDate>Tue, 15 Dec 2009 20:53:53 +0800</pubDate>
    <dcterms:modified>2009-12-16T08:59:46+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[棋牌游戏、桌面游戏和电子游戏的设计感]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009111425147461</link>
    <description><![CDATA[<div><p>昨天去参加桌游比赛，银河竞逐项目我拿了第一，胜妤同学是第二。挺高兴的。不过话说回来，一共也就4个人参加了这个项目（澹。获得三四名的两个参赛选手是代表暴风桌游吧出战的，实力比我们预想的强。我和胜妤半决赛的时候都赢得挺艰难的。我们平时玩银河竞逐都是带了扩展包的，这次比赛是不带扩展包的。为此，胜妤很不适应。据她说，好多战术都没有了，尤其没有了目标卡，游戏变得太简单了。</p>
<p>像银河竞逐这样的桌游，规则很复杂，在设计时需要考虑玩家会采用的战术，战术之间的平衡是由设计者决定的。这和围棋截然不同。围棋的规则简单，变化复杂。甚至围棋的规则简单到了都不能称之为“设计”，只能说是某个古人“发现”了这个游戏。游戏的变化纯粹都是数学规律带来的，只能说是上帝设计的。</p>
<p>不过，围棋作为一种游戏来说，太高端了些，不够大众。第一，围棋学习曲线陡峭，初学者很难入门。第二，围棋没有随机性，棋高一着如泰山压顶，棋力弱的人很难凭借运气获胜，所以下围棋挫折感强。第三，由于围棋规则简单，不够“新奇”，学习过程没有什么“体验感”，所以除非深入的学习围棋，否则很难感受到“有趣”。</p>
<p>上帝设计的游戏的并不一定都有前两个问题。五子棋也是上帝设计的游戏，但五子棋初学者就容易入门，而且水平不高的两个人下五子棋往往也都是有输有赢的。不过第三个问题则是所有上帝设计的游戏都要面对的。上帝设计的游戏和人类设计的游戏是不一样的。国际象棋是人类设计的游戏。国际象棋的棋子就是立体雕刻的，形象具体，“皇后”、“卒子”之类棋子名字富有文化含义，让人一看就觉得有趣。而围棋作为一种上帝设计的游戏，棋子名叫“黑棋”、“白棋”，长得千篇一律，棋盘简单单调。棋局进行时黑白交织一片，理解围棋的人固然能在大脑中感到千军万马的厮杀，可不懂围棋的人只看到了一幅无趣的抽象图案而已。</p>
<p>上帝设计的游戏和人类设计的游戏的这个差异就是“设计感”。所谓“设计感”就是“有意为之”的感觉。围棋没有设计感，国际象棋有设计感；自然风景没有设计感，人工园林有设计感；满天星辰没有设计感，星座图和占星术有设计感；物理规律没有设计感，科普读物有设计感。随机噪音没有设计感，音乐有设计感。</p>
<p>有设计感的东西，是人类有意让它有趣而设计的。这些东西有趣的前提是“新奇”，一旦熟悉了它们，就不有趣了。设计者的苦头就源于此，胜妤以前是做动画编剧的，工作主要是设计广告动画的镜头内容，用草图或者文字的形式表达出来。每每为了“不一样”的设计而绞尽脑汁。不过，这些独特之处正是其工作价值所在。那些千篇一律、似曾相识的东西是没有“设计感”的。</p>
<p>另外，“设计感”是一次性的，用户一旦体验过，他就再也感觉不到有趣了。所以“设计感”是越多越好。</p>
<p>YY小说就是有设计感的。它往往耸人听闻，符合了设计感对“新奇”的要求。它又讲究高速更新，符合了设计感对数量的要求。</p>
<p>游戏设计也是一样。游戏的设计感有两部分来源。一部分是文化上的来源，这部分是美术和文案。比如“魔兽世界”就有海量的任务。另一部分来源是玩法规则，比如“银河竞逐”就有海量的规则。</p><p>要想设计有设计感的规则，必须保持对游戏的控制，如果任凭玩家自己创造出战术，平衡性就难以保证了。星际争霸是公认平衡性极佳的游戏。星际争霸就硬性设定了几种装甲和几种攻击方式之间的攻击加成，兵种相克关系牢牢掌握在设计者笔下。类似的，玩家在什么时间可能建造什么建筑，使用什么战术全都在游戏设计者的考虑中。一旦出现不平衡的战术，就发布补丁扼杀，比如 1.08 版地刺的涨价。</p><p>我想，要想制作一款好玩有趣的游戏，就得切实提供大数量高质量的玩法、大数量高质量的美术和文案。而依靠几个基本公式外加部分随机数，指望上帝来设计游戏，是不行的。即使上帝真的设计出了复杂的变化，可以让高端玩家深入研究，这样的游戏也一样会缺乏设计感。</p></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009111425147461</comments>
    <slash:comments>2</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009111425147461</guid>
    <pubDate>Mon, 14 Dec 2009 14:51:47 +0800</pubDate>
    <dcterms:modified>2009-12-18T22:20:48+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[ActionScript 3 bug: delete Array项可能删不掉，反而变出来一些奇怪的值]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009114104442870</link>
    <description><![CDATA[<div><div><span style="font-family: Arial, sans-serif; line-height: normal; font-size: 12px; -webkit-border-horizontal-spacing: 1px; -webkit-border-vertical-spacing: 1px; ">Steps to reproduce:&nbsp;</span></div><div><span style="font-family: Arial, sans-serif; line-height: normal; font-size: 12px; -webkit-border-horizontal-spacing: 1px; -webkit-border-vertical-spacing: 1px; ">1. compile the following co<wbr>de:&nbsp;<br>package {&nbsp;<br>imp<wbr>ort flash.display.*&nbsp;<br>imp<wbr>ort flash.utils.*&nbsp;<br>public final class Delete extends Sprite {&nbsp;<br>public function Delete() {&nbsp;<br>//const a:* = {}&nbsp;<br>const a:Array = []&nbsp;<br>function put(k:uint):void {&nbsp;<br>a[k] = Math.random()&nbsp;<br>}&nbsp;<br>function remove(k:uint):void {&nbsp;<br>const before:Number = a[k]&nbsp;<br>delete a[k]&nbsp;<br>const after:Number = a[k]&nbsp;<br>if (a[k] != null) {&nbsp;<br>throw new Error(&nbsp;<br>"Incorrect deletion:" +&nbsp;<br>"before=" + before + "," +&nbsp;<br>"after=" + after)&nbsp;<br>}&nbsp;<br>}&nbsp;<br>for (var i:uint = 0;;i++) {&nbsp;<br>put(uint(Math.random()*4))&nbsp;<br>remove(uint(Math.random()*4))&nbsp;<br>}&nbsp;<br>}&nbsp;<br>}&nbsp;<br>}&nbsp;<br><br>2. Run it in debugger version Flash Player&nbsp;<br>&nbsp;&nbsp;<br>Actual Results:&nbsp;<br>Throw an error.&nbsp;<br>&nbsp;&nbsp;<br>Expected Results:&nbsp;<br>Do not throw any error.&nbsp;<br>&nbsp;&nbsp;<br>Workaround (if any):&nbsp;<br>Delete it twice!&nbsp;<br></span></div><div><br></div><div>这个 bug 其实涉及最基础的类，任何版本的 FlashPlayer 9 和 FlashPlayer 10 都能重现。我已经报告了（<a href="http://bugs.adobe.com/jira/browse/FP-2798" target="_blank">http://bugs.adobe.com/jira/browse/FP-2798</a>）。但是需要多几个人投票， Adobe 才会注意到它。如果你也碰到这个 bug ，就投上一票（需要注册）吧。</div></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009114104442870</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009114104442870</guid>
    <pubDate>Fri, 4 Dec 2009 22:44:42 +0800</pubDate>
    <dcterms:modified>2009-12-04T22:45:42+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[在 mxmlc 编译的 swf 中使用 swfc 编译的 swf]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/1364905620091025103353300</link>
    <description><![CDATA[<div><a href="http://www.swftools.org/" target="_blank">SWFTOOLS</a> 是一套 swf 文件相关工具，其中的&nbsp;<a href="http://www.swftools.org/swfc/swfc.html" target="_blank">swfc</a> 能把 .sc 格式的源文件编译成 .swf 文件。我<a href="http://www.ac.net.blog.163.com/blog/static/13649056200973094427355" target="_blank">以前</a>以为他是没有办法向 ActionScript 导出资源的，不过这两天我最终还是找到办法能够在 mxmlc 编译的 .swf 中使用 swfc 导出的资源，最关键的是，能够静态链接到这些资源。

<div>首先，编写 .sc 文件的时候，要再多写一个 .as 文件，在里面编写要生成的 swf 的主类，主类要从 flash.display.Sprite 派生出来（当然 flash.display.MovieClip 也可）。如果资源中用到了 .png 之类指令定义的形状，主类中也得声明。</div>



<fieldset>
<legend>ResourceMain.as</legend><pre>package {
  imp<wbr>ort flash.display.*
  public class ResourceMain extends Sprite {
    public var png1:Shape
  }
}</pre>
</fieldset>



<div>其次，.sc 文件要用 .act<wbr>ion 指令引用定义主类的 .as 文件。</div>

<fieldset>
<legend>ResourceMain.sc</legend><pre>.flash bbox=200x200 version=6 fps=50 name="ResourceMain.swf" compress
.act<wbr>ion filename="ResourceMain.as"
.png png1
# ...
.end
</pre>
</fieldset>


<div>这样一来，就可以用 swfc 编译一个有主类的 swf 了。你可以用 Loader 加载它，然后调用 Loader 的 contentLoaderInfo.applicationDomain.getDefinition("ResourceMain") 方法来获取这个类。</div><div>如果要在编译时就找到这个类的符号，想要直接 imp<wbr>ort 这个类，还要做以下两个步骤：</div><div><ol><li>用 compc 编译那个主类的 .as 文件。这样编译出来的 swc 只包含类定义，而没有资源素材。</li><li>用 mxmlc 编译主程序的时候，用 -compile.extern-library-path 而不是 -compile.library-path 引用上一步编译出来的 swc</li></ol>用这种办法编译出来的主程序认识资源的符号，但是并不包含资源，所以必须在运行时用 Loader 把资源 swf&nbsp;加载到ApplicationDomain.currentDomain&nbsp;之后再用那些用到了该资源的函数或者类，不然就会有运行时异常。</div>

<fieldset>
<pre>var loader:Loader = new Loader
loader.load(new URLRequest("resource.swf"), new LoaderContext(false, ApplicationDomain.currentDomain))</pre>
</fieldset>

<div>如果不想在运行时加载，而想静态链接，用&nbsp;<a href="http://www.swftools.org/swfcombine.html" target="_blank">swfcombine</a>&nbsp;把资源 swf 捆进主程序即可。</div><div><br></div><div>顺便说一句，swfc 不支持中文变量名或类名，我写了一个补丁让它支持，在这里下载：</div><div><a href="http://lists.gnu.org/archive/html/swftools-common/2009-11/msg00141.html">http://lists.gnu.org/archive/html/swftools-common/2009-11/msg00141.html</a></div></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/1364905620091025103353300</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/1364905620091025103353300</guid>
    <pubDate>Wed, 25 Nov 2009 22:33:53 +0800</pubDate>
    <dcterms:modified>2009-11-25T22:36:34+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[用 lua 代替 GNU Make]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200910158757960</link>
    <description><![CDATA[<div>我们团队一直在用 GNU Make ，我们老大<a href="http://blog.codingnow.com/" target="_blank">云风</a>尤其<a href="http://blog.codingnow.com/eo/build_tool/" target="_blank">把 make 用得十分高级</a>。但使用过程中，碰到一些问题确实比较讨厌：

<ol>
<li>斜杠的处理</li>
参见 <a href="http://blog.codingnow.com/2009/03/gnu_make_backslash.html" target="_blank">http://blog.codingnow.com/2009/03/gnu_make_backslash.html</a>。

<li>递归目录</li>
参见 <a href="http://blog.codingnow.com/2009/06/make_recursion_directory.html" target="_blank">http://blog.codingnow.com/2009/06/make_recursion_directory.html</a>，这个用到了神技<a href="http://www.linuxsir.org/main/doc/gnumake/GNUmake_v3.80-zh_CN_html/make-08.html#_gnu_make_8.8" target="_blank">（ｅｖａｌ）</a>。
<li>自动创建目录 </li>
参见 <a href="http://blog.codingnow.com/2009/07/gnu_make_mkdir.html" target="_blank">http://blog.codingnow.com/2009/07/gnu_make_mkdir.html</a>，这个也用到了神技。<li>包含空格的文件名的处理</li>据高人说，可以在调用&nbsp;<a href="http://www.linuxsir.org/main/doc/gnumake/GNUmake_v3.80-zh_CN_html/make-08.html#_gnu_make_8.4%20" target="_blank">foreach</a> 等内置函数以前先把空格替换成别的字符，再在作为文件名使用时把空格替换为<q> </q>。但这个做法等于是自己定义一种转义规则了。

<li>shell的依赖性</li>
make 的命令行都是调用操作系统的 shell ，这样会带来移植性问题。就连基本的文件操作都需要定义很多环境变量来处理 cp / copy cat / type 之类的差异。不同操作系统的命令行转义规则也各不相同，如果命令行参数中出现特殊字符，要想在不同的 shell 下都正确转义难度极大。

<li>算术运算</li>比如我想要从 1 循环到 10，声明 frame_1.png 依赖于 frame_1.tga，frame_2.png 依赖于 frame_2.tga，frame_3.png 依赖于 frame_3.tga …… frame_10.png 依赖于 frame_10.tga。这样的事情在 C 里面就是 for (i = 0; i &lt; 10; ++i) 即可。在 make 中， for 倒是可以用递归来模拟，但 make 里面除非求助于 shell 就没有办法能做 ++i 这个事情。

<li>子模块依赖关系</li>这个是 make 的死穴。如果一个项目中有多个模块，模块 a 依赖于模块 b 的输出文件 libb.a，那应该怎么写依赖关系呢？一般有两种做法<ul>
<li>不同的模块使用独立的 Makefile ，a 模块依赖于 libb.a，如果 libb.a 不存在，就调用 b 模块的 make 来创建 libb.a，大概代码如下： <fieldset><pre>../b/libb.a:<br> cd ../b &amp;&amp; $(MAKE)<br><br>a.exe: ../b/libb.a xxx.c yyy.c xxx.h<br> gcc ……</pre></fieldset></li>
这样做的问题在于如果模块 b 中的某个源文件修改了，在 a 模块下 make 时， libb.a 不能自动重新编译，因而 a 模块也不会重新编译<li>用 include 之类的办法把所有模块的 Makefile 统一起来，这是目前我们做的方式。缺点在于：
<ul>
<li>编写子模块的 Makefile 时需要知道别的模块的信息，破坏了 Makefile 的局部性</li>
为了解决这个问题，云风想的办法是自己定义了一套语法，在子模块 make 时，通通调用根一级的 Makefile ，只是把子模块的信息通过环境变量传进去。但这样带来了另一个缺点，即自定义的语法有学习成本，和直接的 make 语法相比，维护起来要稍微困难一些。
<li>即使只构建一个子模块，也需要生成整个项目的依赖图</li>
尤其当文件很多的时候，生成整个依赖图会比较慢。这个问题在 bjam 中也存在。因为我们现在的做法就相当于用 make 实现了一套 bjam ，所以我们也会面临 bjam 的一些问题。
</ul>

</li>
<ul></ul></ul></ol>
<p>当一个项目构建过程比较复杂的时候，可以考虑用通用语言来管理构建过程。对于通用语言来说，处理字符串转义、算术运算、循环遍历等事情易如反掌，无需使用 make 那些神奇而又晦涩的神技。而跨平台的通用语言的文件系统库往往也比 shell 有更好的移植性。至于子模块依赖问题，对于支持 closure 、 coroutine 的语言来说，很容易就能实现依赖关系的惰性计算，只需要生成整个依赖图中于构建目标相关的那部分，速度就快多了。</p>

<p>我在做的一个项目的构建过程就十分复杂，需要把一些配置文件从一种格式转成另一种格式，然后再嵌入主程序中；用到的美术素材也需要转格式。这些过程需要用到好几种转换工具，有一些转换工具就直接要用 lua 编写。我原先是用 GNU Make 来做这件事情的，把各种神奇的特性都用上了，最后碰到空格文件名的时候，还是放弃了，决心自己用 lua 实现一套构建系统，我把它叫做 lua-make</p>

<p>
因为编译器、转换工具都是命令行工具，所以这个构建系统碰到的第一个问题是要能启动进程。lua 标准库中启动进程有两个函数，io.popen 和 os.execute 。其中 io.popen 不支持 Windows。而 os.execute 要依赖于操作系统的 shell ，移植性不佳比如，在 bash 中，我们可以写这样的代码：
</p><fieldset><pre>cat 111.txt | a/b/foo 'xxxxx' | bar 'yyyyy' 'aaa' 2&gt; out/err &gt; out/log</pre></fieldset>








<p>如果要用 lua 来启动，就是</p><fieldset><pre>os.execute[[cat 111.txt | a/b/foo 'xxxxx' | bar 'yyyyy' 'aaa' 2&gt; out/err &gt; out/log]]</pre></fieldset>
<p>可是上述代码在 Windows 中就跑不通了。这是因为 Windows 的 shell 是 cmd ，语法不同，<a href="/blog/static/136490562009913102521413" target="_blank">字符串转义规则不同</a>，目录分隔符也不同。</p><p>归根到底， os.execute 是不可移植的。所以我用了 <a href="http://lua-ex.luaforge.net/" target="_blank">Lua-Ex</a> 。Lua-Ex 提供了创建管道的函数（ex.pipe），启动进程并重定向标准输入输出的函数（ex.spawn），刚好适合做构建系统。不过，pipe 和 spawn 是比较底层的函数，要想简单的完成一串管道的命令，还需要一些语法糖。</p><p>我做了一个 path 模块和一个 shell 模块来做实现这个语法糖。先前的 bash 表达式，用我提供的语法糖来写的话就是这样：</p><fieldset><pre>"111.txt" / path["a/b/foo"]("xxxxx") / path["bar"]('yyyyy', 'aaa') % path["out/err"] / path["out/log"]</pre></fieldset>

<p>上述表达式中，运算符<q>/</q>用来重定向标准输出，相当于 bash 中的<q>|</q>、<q>&lt;</q>或<q>&gt;</q>；运算符<q>%</q>用来重定向标准错误，相当于 bash 中的<q>2&gt;</q>。</p>
<p>
path["out/log"] 是一个路径对象。我重载了路径对象metatable中的 __div ，所以也可写成 path["out"] / path["log"] 或者 path.out / path.log 又或者 path.out / "log" 。如果用 setfenv 把当前执行环境设成 path ，甚至可以直接写成 out/log 。</p><p>路径的比较也十分简单，我能保证同一个路径在内存中只有一份，所以 path["x/b"] 、 path["x"] / b 、 path["x/a/../b"] 、 path["x\\b"] 都是同一个对象。<br></p><p>我也重载了路径对象metatable中的 __call ，当它被调用的时候就会被当成可执行文件来执行。这就是为什么上述代码可以直接写path["bar"]('yyyyy', 'aaa') 的缘故。</p><p>对于一个构建系统来说，核心部分是目标的依赖关系管理。这方面，我主要是造搬 GNU Make 的模型，只是语法用 lua 的表来描述。</p><p>这里我碰到一个问题，就是多任务的并行执行。make 有一个 -j 选项，可以并行执行多个任务。用 lua 怎么实现类似的功能呢？用 ex.spawn 可以创建进程，用 ex.wait 可以等待一个进程退出，但是如果同时启动了多个进程，怎样才能等待其中任意一个退出呢？Windows 中有一个 WaitForMultiObjects 可以做这件事情，但是一方面这不可移植，另一方面我也不想为了这一个功能而多写一个 lua C库。我用的办法是在主进程调用 ex.pipe 创建一个 pipe，为需要监视的进程创建一个辅助进程来监视，辅助进程等待被监视的进程退出，退出时向 pipe 发一个消息。所以主进程之需要读这个 pipe 就可以知道任意一个进程退出了。我把这个监视模块叫做 shell.watchdog 。<br></p><p>最终，要使用这个构建系统，大概是这样来写Makefile：</p>





<fieldset><pre>require "shell"<br>require "path"<br>require "shell.watchdog"<br>require "make"<br>require "make.filetarget"<br><br>local watchdog = shell.watchdog()<br><br>make(10, make.filetarget {<br>  path = "xxxx.exe",<br>  dependencies = {<br>    {<br>      run = function ()<br>        print("这是一个伪目标")<br>      end<br>    },<br>    make.filetarget {<br>      path = "xxxx.c"<br>    },<br>    make.filetarget {<br>      path = "xxxx.h"<br>    }<br>  }<br>  run = watchdog + path.gcc("-o", "xxxx.exe", "xxxx.c")<br>})<br><br>watchdog:wait()<br></pre></fieldset>


<p>make 函数的第一个参数指最多允许多少个并行任务的意思，这里传 10，就相当于GNU Make 的 -j 10</p><p>make.filetarget 是说这是一个文件目标，而不是一个伪目标（即 GNU Make 的 .PHONY）。文件目标和伪目标相比，要增加判断文件修改时间、自动创建父级目录等功能。在我实现的构建系统中，一个目标默认是没有这些功能的，如果需要这些功能就得写 make.filetarget {......}<br>
</p><p>这里的<q>watchdog +</q>是一个语法糖，意思是要把接下来的这一段 shell 表达式加入到 watchdog 这个监视对象中去监视。</p>
<p>大体上我就是这样实现 Lua 构建系统的，欢迎回帖讨论</p></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200910158757960</comments>
    <slash:comments>6</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200910158757960</guid>
    <pubDate>Sun, 15 Nov 2009 22:28:49 +0800</pubDate>
    <dcterms:modified>2009-11-15T22:36:57+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[trackAsMenu的作用]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200991691444451</link>
    <description><![CDATA[<div><p>用ActionScript的时间长了，实在是不能容忍里面还有我不认识的API。昨天终于搞清楚trackAsMenu的用处了，于是AS里面我不认识的API又少了一个。</p><p>在Flash创作工具中文版的界面上，这个trackAsMenu被翻译为“音轨作为菜单”，看到这几个字，我眼睛湿润了。trackAsMenu的意思应该是“以菜单的方式追踪鼠标”。这个选项在ActionScript3里面是SimpleButton和MovieClip上的属性，如果打开这个选项，有两个效果：</p>
<ol>
<li>如果在别的对象上按下鼠标，然后不松开鼠标，移到一个trackAsMenu为true的对象上，再松开鼠标的话。这个trackAsMenu为true的对象就会收到MouseEvent.CLICK事件。而如果把trackAsMenu设为false的话，这个click事件是收不到的。</li><li>如果在一个trackAsMenu为true的对象上按下鼠标，然后不松开鼠标，移到另一个trackAsMenu为true的按钮上，进入的这个按钮会显示overState的图像。但如果是移到另一个trackAsMenu为flase的按钮上，则那个按钮还是显示upState的图像。</li></ol>
<p>所以，这个功能用来制作菜单时会有用。只要把各个菜单项都设上trackAsMenu属性，原先按下鼠标时的那个对象以外的对象也可以触发click事件了。</p></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200991691444451</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200991691444451</guid>
    <pubDate>Fri, 16 Oct 2009 09:14:44 +0800</pubDate>
    <dcterms:modified>2009-10-16T09:14:44+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[Windows命令行参数的转义]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009913102521413</link>
    <description><![CDATA[<div><p>Windows命令行参数的转义分为两个步骤，第一个步骤是cmd解析你输入的字符串决定要启动哪些进程，进程之间是否要标准输入输出重定向等等；第二个步骤是CRT把传入进程的命令行字符串切成多个参数，填好argc和argv传入main。</p><p>如果一个程序不是被cmd启动的，而是通过快捷方式或者bash等别的shell启动的，或者干脆直接调用API CreateProcess，那么第一个步骤可以无视；如果一个程序并不使用argc、argv，而自行调用GetCommandLine等Windows API，则第二个步骤可以无视。</p><p>第一个步骤中，<quote>| ^ " &amp;</quote>等字符是特殊字符。如果特殊字符出现在双引号外，需要被转义。但如果出现在双引号中，就不需要也不能被转义。转义时，<quote>^^</quote>代表<quote>^</quote>，<quote>^|</quote>代表<quote>|</quote>，<quote>^"</quote>代表<quote>"</quote>等等</p>

<p>第二个步骤的具体实现取决于CRT，在Windows XP中用得最广泛的CRT是msvcrt.dll。Windows XP附带的系统程序大都使用了它，用VC6或mingw的gcc编译的程序也使用这个CRT。我看了一下VC6附带的源码，切参数这件事情的规则相当复杂。</p><p>首先是空格和tab如果不在双引号，就会被当作参数的分隔符，而双引号引住的空格和tab代表空格tab字符本身。</p><p>其次是连写双引号的特殊处理。如果想要把双引号作为参数内的字符，那么至少要连写两个双引号：<quote>""</quote>。当他遇见连续的两个双引号时，他会把其中一个双引号作为双引号字符，另一个双引号作为引用范围的开始或结束。也就是说，如果你已经在引号中了，连写2个双引号的话，就会产生一个<quote>"</quote>字符，并且关闭引用。要想产生一个<quote>"</quote>字符但不改变引用状态，就需要连写三个双引号<quote>"""</quote>。</p><p>最变态的是用反斜杠（即<quote>\</quote>）转义的规则。对于n个反斜杠外加一个双引号会被转义。如果n为奇数，那么会被转义成(n-1)/2个<quote>\</quote>字符外加一个<quote>"</quote>字符。如果n为偶数，那么会被转义成n/2个<quote>\</quote>字符，然后再进入或结束引用范围。而如果反斜杠后面并不跟随双引号，反斜杠就不转义。</p><p>值得注意的是，因为cmd和CRT对双引号字符的转义规则并不一致，所以cmd和CRT对于某个字符是否被引用的判断也是不一致的。比如说，如果你想进行一次Subversion提交，注释中写上</p><pre><quote>hello " | " |   " | "  world</quote></pre>，那你得写：<quote><pre>svn commit -m "hello """ ^| """ |   """ ^| """  world"</pre><p>注意，其中某些<quote>|</quote>必须要转义，而另一些则必须不转义。</p><p>上面说的还仅仅是msvcrt.dll切参数的规则，这个规则和cygwin的CRT是不一致的，也就是说，如果你在cmd中要调用cygwin编译的程序，那么转义规则又不一样。幸好这种情况并不是很多，用cygwin的话，就用bash好了，至少全世界的bash解析参数的方式都一样。</p></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009913102521413</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009913102521413</guid>
    <pubDate>Thu, 15 Oct 2009 21:37:21 +0800</pubDate>
    <dcterms:modified>2009-10-15T21:51:42+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[放弃在现有项目中使用haXe]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009820561780</link>
    <description><![CDATA[<div><p>第一个原因是如果新写的代码改用haXe，新写的代码依赖于部分AS代码，而另一部分AS代码又会依赖于haXe，那么就会导致循环依赖。虽然有办法可以解决，但是每种解决方案都有代价，要么是把现有AS代码拆成两部分来编译，要么是用ApplicationDomain.getDefinition之类的字符串解耦合办法。这些办法都不是我想要的。</p><p>第二个原因在于haXe用的全局变量flash.Lib.current. 把一段haXe代码编译成SWC或者SWF，分别作为静态库和动态库使用时，会有微妙的差异（参见<a href="http://haxe.org/doc/advanced/swc" target="_blank">http://haxe.org/doc/advanced/swc</a>）。而我如果想要在开发期间缩短编译时间，必须要把haXe部分编译成动态链接的SWF。这个问题体现了“全局变量的邪恶性”。全局变量之所以邪恶在于其“全局”概念的不可控，在模块角度看是全局的东西，到了装载器的角度来看就有时候是而有时候不是了，就会导致行为不一致。</p><p><br></p></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009820561780</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009820561780</guid>
    <pubDate>Wed, 2 Sep 2009 12:56:01 +0800</pubDate>
    <dcterms:modified>2009-09-02T12:56:01+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[非主流的一些flash开发工具]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200973094427355</link>
    <description><![CDATA[<div>
<p>主流的flash开发工具当然是Flex Builder/Flex SDK/Flash创作工具。一般用Flash创作工具生成素材，用Flex SDK来编译代码，喜欢IDE环境的就用用Flex Builder。但除此之外，还有一些非主流的开发工具选择。</p>
<p>现在能生成flash的编译器已经有很多了，真的不必拘泥于龟一般的mxmlc. <a target="_blank" _fcksavedurl="http://www.ac.net.blog.163.com/blog/static/13649056200973015541880/" href="/blog/static/13649056200973015541880/">前一篇文章</a>，我介绍了<a target="_blank" _fcksavedurl="http://www.haxe.org/" href="http://www.haxe.org/">haXe</a>。除此之外，另一个选择是<a href="http://www.swftools.org/" target="_blank">swftools</a>中的<a href="http://wiki.swftools.org/index.php/As3compile" target="_blank">as3compile</a>，这个编译器号称是要兼容mxmlc，不过就我目前测试的情况来看，它有一个缺陷，即不支持闭包中访问upvalue。</p>
<p>当然我不认为mxmlc慢是因为它用了Java，javac也是Java写的，快得很呢。</p>

<p>由于AVM开源了，还可以用AVM开源后提供的编译器，AVM开源后的项目名叫做<a href="https://developer.mozilla.org/en/Tamarin" target="_blank">Tamarin</a>，源码在<a href="http://hg.mozilla.org/tamarin-central/archive/tip.tar.bz2" target="_blank">这里下载</a>。这是一个C++编写的编译器，现在想尝尝鲜的话，可以找到Tamarin里面的utils/avmc，里面就是这个编译器。不过avmc编译出来的目标文件是.abc，还需要包装上swf的文件头才能用，这件事情可以用前面提到的as3compile来做。比较头疼的问题在于如何引用flashplayer的API，这些API在flex_sdk_3/frameworks/libs/player/playerglobal.swc里面是有，要把这个playerglobal.swc导出成.abc我没试过，但应该不难。</p>
<p>以上是一些编译器，至于素材的制作，可以考虑<a href="http://www.swftools.org/" target="_blank">swftools</a>中<a target="_blank" _fcksavedurl="http://wiki.swftools.org/index.php/Swfc" href="http://wiki.swftools.org/index.php/Swfc">swfc</a>。和官方的Flash创作工具相比，它的优势在于源文件.sc格式是一个文本格式，工具又是命令行工具，因此易于用脚本生成代码。缺点有两个，首先是缺乏“所见即所得”编辑器，其次是一些功能缺失，比如向ActionScript导出元件。用swfc来打包素材已经足用了，我就用swfc来把一些公司自定格式的动画素材批量转换成swf格式。</p>
</div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200973094427355</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200973094427355</guid>
    <pubDate>Sun, 30 Aug 2009 21:44:27 +0800</pubDate>
    <dcterms:modified>2009-08-30T21:44:27+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[haXe 学习笔记]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200973015541880</link>
    <description><![CDATA[<div><p>其实我早就听说过haXe。那是大概两年前，mtasc停止开发，转而开发haXe. 当时我没怎么注意，直到现在对mxmlc的编译速度忍无可忍的时候，才偶然发现改用haXe也许是个解决办法。</p>

<p>haXe主页上强调这是一种“multiplatform language”的语言，可以编译成JavaS<wbr>cript、Flash、NeckoVM（这个没听说过）、PHP、C++。不过这些我不关心，我只关心它能编译成Flash.</p><p>从haXe的语言特性来看，这是一种大路货的面向对象语言，跟Java、C#、ActionScript3都差不多。对我而言，haXe比ActionScript3好的地方有：</p>


<ol><li>haXe编译速度奇快，比mxmlc快得多，这应该是选用它的最大动机。</li><li>更完备的静态类型系统。比如支持泛型，此外，其函数类型也是强类型。这解决了<a target="_blank" href="/blog/static/136490562009714113153722/edit/">ActionScript3语言陷阱和缺陷</a>一文提到的第三个缺陷</li><li>支持类型推断，不用每个变量都写类型。</li><li>局部变量的范围是某个区块而不是整个函数。这解决了<a target="_blank" href="/blog/static/136490562009714113153722/edit/">ActionScript3语言陷阱和缺陷</a>一文提到的第四个缺陷</li><li>支持枚举<br></li></ol>
<p>haXe比ActionScript3差的地方有：</p>
<ol><li>不支持自由函数，因而函数必须放在类中。flash.utils.setTimeout等自由函数也就不能直接调用了。</li><li>没有const关键字。</li></ol>

<p>从ActionScript3迁移到haXe时还需要考虑的事情包括：</p>
<ol>
<li>调试。根据我测试，在haXe 2.x中只需要加上 -debug -D fdb 参数就可以使用Flex SDK中的fdb来调试了。</li><li>动态加载。这个说来话长，得另写一篇文章来说这个问题了。简单的说一下要点吧。要使用 haxe --gen-hx-classes 来生成头文件以便在编译时找到符号，然后在运行时加载动态库。运行时加载要指定传一个ApplicationDomain.currentDomain进去。</li><li>如果想要和现有的swf编译到一起，需要用-swf-lib把已有的swf捆进来。此外，调用其中已有的AS代码则还需要--gen-hx-classes生成的头文件。AS要调用haXe代码的话，则需要haxe -swf9 xxx.swc来生成一个swc文件让AS能通过这个文件找到符号</li><li>要编译一般在网上用的swf，需要加入-D network-sandbox参数。</li><li>haXe的学习成本。对我而言，学习成本很低，花费一天时间足够搞懂。再次强调，这是一种大路货语言。语法和ActionScript区别不大，就算有些犄角旮旯之处不同，遇到时也很容易解决。比较讨厌的一个语法在于每行代码都必须加上分号。</li></ol></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200973015541880</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200973015541880</guid>
    <pubDate>Sun, 30 Aug 2009 21:13:40 +0800</pubDate>
    <dcterms:modified>2009-08-30T21:13:40+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[ActionScript3语言陷阱和缺陷]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009714113153722</link>
    <description><![CDATA[<div><ol><li><h3>闭包会产生多余的引用</h3></li>
ActionScirpt3的闭包会引用外层函数的所有局部变量，而不仅仅只是用到的变量。这些多余的引用是不必要的。它们会使垃圾收集器认为这些数据仍然被引用着而不去释放，哪怕这些数据本来已经不可能再被用到。例如，以下代码会导致内存泄露：<fieldset><pre>package {<br>  imp<wbr>ort flash.display.*<br>  public final class C extends Sprite {<br>    private static function ref(f:Function):Function {<br>      return function():void {<br>      }<br>    }<br>    private var f:Function = function():void{}<br>    public function C() {<br>      for(var i:uint = 0; i &lt; 1000000; i++) {<br>        f = ref(f)<br>      }<br>    }<br>  }<br>}<br></pre></fieldset>


<li><h3>与JavaS<wbr>cript的异同</h3></li>
ActionScript2和JavaS<wbr>cript一致的地方更多些，而ActionScript3则少一些，这样会迷惑很多用惯JavaS<wbr>cript的人，例如：<br><a href="/blog/static/1364905620060274329791/" target="_blank">
http://www.ac.net.blog.163.com/blog/static/1364905620060274329791/</a><br><a href="/blog/static/1364905620060297425813/" target="_blank">
http://www.ac.net.blog.163.com/blog/static/1364905620060297425813/</a><br>
还有一些区别在ASDoc中也提到了，比如=== 和 == 用在Number、uint、String上时，AS2和AS3行为是不同的。


<li><h3>编译器不检查函数返回值类型</h3></li>

例如，以下代码可以通过编译。

<fieldset><pre>function xxx():uint {<br>  return 0<br>}<br>var a:Array = xxx()</pre></fieldset>



<li><h3>局部变量的范围是整个函数而不是某个区块</h3></li>

例如以下代码会出错：<fieldset><pre>function f(b:Boolean):void {<br>  if(b) {<br>    var a:String = "a"<br>  } else {<br>    var a:Array = []<br>  }<br>}</pre></fieldset>
这一点对于闭包的使用来说，很麻烦，例如
<fieldset><pre>var a:Array = []<br>for(var i:uint = 0; i &lt; 10; i++) {<br>  a[i] = function():uint {<br>    return i<br>  }<br>}<br>trace(a[3]()) // 输出10而不是3<br></pre></fieldset>

上述代码会trace出 10 而不是 3

<li><h3>const并不真的不可改变</h3></li>
更有甚者，即使你使用 const 关键字声明一个常量，实际上它还是会被改变：

<fieldset><pre>var a:Array = []<br>for(var i:uint = 0; i &lt; 10; i++) {<br>&nbsp; const c:uint = i<br>  a[i] = function():uint {<br>    return c<br>  }<br>}<br>trace(a[3]()) // 还是输出10而不是3</pre></fieldset>

<li><h3>setTimeout不自动释放对闭包的引用</h3></li>
ASDoc中的的文档有下面这句话：
<fieldset>If you intend to use the
         clearTimeout()
          method to cancel the
          setTimeout()
          call, be sure to assign the
          setTimeout()
          call to a
 variable (which the
         clearTimeout()
          function will later reference).
 If you do not call the
          clearTimeout()
          function to cancel the
      setTimeout()
          call, the object containing the set timeout closure 
 function will not be garbage collected.</fieldset>
意思是说，如果是说可以用clearTimeout来取消setTimeout设置的定时器。让人觉得言下之意是，如果不想取消定时器，不调用clearTimeout也可以。实际上，如果不调用clearTimeout，就会导致内存泄露。setTimeout并不自动释放对闭包的引用。


</ol>

</div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009714113153722</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009714113153722</guid>
    <pubDate>Fri, 14 Aug 2009 11:31:53 +0800</pubDate>
    <dcterms:modified>2009-10-19T19:03:53+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[D语言2.0的const和immutable]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200971294550714</link>
    <description><![CDATA[<div><fieldset>
<legend>翻译后记</legend>
2007年的时候，我关注过D语言，甚至还用它来写过一个东西。当时D社区里面讨论得比较激烈的特性就是final/const/invariant这三种数据类型。那时候我就觉得D 2.0的这三个东西会很有用。<br>过了两年，突然发现这些东西已经改得面目全非，invariant已经改名叫做immutable了，而final数据类型竟然被砍掉了。我在D的论坛上泡了半天也没搞清楚前因后果。所以我翻译了这篇文章，可能会对被D语言这些常量所迷惑的同学有帮助。原文地址：<a href="http://www.digitalmars.com/d/2.0/const3.html" target="_blank">http://www.digitalmars.com/d/2.0/const3.html</a></fieldset>
<p>对数据结构或接口来说，如果能轻易地分辨出哪些数据不会改变，哪些数据可能会改变，以及谁可能改变这些数据，就会非常有用。以上可借助语言的类型系统做到。数据可以被标记为const或immutable，而其默认是<i>可变的</i>（即<i>mutable</i> ） 。</p> <p>不
可改变的数据可以用immutable表示。immutable数据构建之后，在程序整个运行期间都会保持原值。immutable数据可以放在
ROM（只读存储器）中或者由硬件设为只读的内存中。由于immutable数据不会改变，所以可以得到许多程序优化的机会，还可便于采用函数式编程。</p> <p>const适用于不能通过引用本身改变数据的引用。不过，这块数据还时可能被其他引用所改变。若向接口传入数据时需要保证该接口中不修改该数据，则应采用const。</p> <p>immutable和const都是<i>transtive</i>（具有<i>可传递性</i>），这意味着通过immutable引用取得的数据同样也是immutable的，const亦是如此。</p> <h2>immutable存储类</h2> <p>immutable最简单的用法是用作存储类。可以用它来声明明确的常量。</p> <pre><span>immutable</span> <span>int</span> x = 3; <span>// 将x设为3<br></span>x = 4;   <span>// 错误，x不可改变<br></span><span>char</span>[x] s;  <span>// s 是一个包含三个char的数组<br></span></pre> <p>数据类型也可以由初始化表达式推断：</p> <pre><span>immutable</span> y = 4; <span>// y的类型是int<br></span>y = 5;   <span>// 错误，y不可改变<br></span></pre> <p>如果不写初始化表达式，相应的构造函数也可以初始化immutable数据：</p> <pre><span>immutable</span> <span>int</span> z;<br><span>void</span> test()<br>{<br>    z = 3;  <span>// 错误，z不可改变<br></span>}<br><span>static</span> <span>this</span>()<br>{<br>    z = 3;    <span>// 正确，没有静态初始化表达式的immutable数据可以赋值<br></span>}<br></pre> <p>除了函数类的immutable数据外，其他immutable声明的初始化表达式都必须能在编译时求值：</p> <pre><span>int</span> foo(<span>int</span> f) { <span>return</span> f * 3; }<br><span>int</span> i = 5;<br><span>immutable</span> x = 3 * 4;      <span>// 正确，12<br></span><span>immutable</span> y = i + 1;      <span>// 错误，无法在编译时求值<br></span><span>immutable</span> z = foo(2) + 1; <span>// 正确，foo(2)能在编译时求得值――7<br></span></pre> <p>非静态的局部immutable数据的初始化表达式是在运行时计算的：</p> <pre><span>int</span> foo(<span>int</span> f)<br>{<br>  <span>immutable</span> x = f + 1;  <span>// 运行时求值<br></span>  x = 3;                <span>// 错误，x不可改变<br></span>}<br></pre> <p>由于immutable数据具有可传递性，由immutable数据引用的数据也是不变的：</p> <pre><span>immutable</span> <span>char</span>[] s = <span>"foo"</span>;<br>s[0] = 'a';  <span>// 错误，s指向一块不可改变的数据<br></span>s = <span>"bar"</span>;   <span>// 错误，s不可改变<br></span></pre> <p>immutable声明可以作为左值出现，比如它们的地址都是可以获取到的，再如它们会占据存储空间。</p> <h2>const存储类</h2> <p>除了以下区别之外，以const声明的数据和immutable的完全相同：</p> <ul><li>不能通过const声明来修改它所引用的数据，但这块数据还是可能被指向该数据的其他引用所修改。</li><li>const声明自身也是const的。</li></ul> <h2>immutable类型</h2> <p>一定不会被改变的数据可以标记为immutable。immutable关键字可以被用作<i>type constructor</i>: </p> <pre><span>immutable</span>(<span>char</span>)[] s = <span>"hello"</span>;<br></pre> <p>括号中的类型被标记为immutable。因此，一方面，<tt>s</tt>能被设为新的值，另一方面，<tt>s[]</tt>的内容却不能被改变：</p> <pre>s[0] = 'b';  <span>// 错误，s[]不可改变<br></span>s = <span>null</span>;    <span>// 正确，s自身并不是immutable的<br></span></pre> <p>immutable具有可传递性，这意味着被immutable类型引用的数据也是immutable的：</p> <pre><span>immutable</span>(<span>char</span>*)** p = ...;<br>p = ...;        <span>// 正确，p可以改变<br></span>*p = ...;       <span>// 正确，*p可以改变<br></span>**p = ...;      <span>// 错误，**p不可改变<br></span>***p = ...;     <span>// 错误，***p不可改变<br></span></pre> <p>把immutable用作存储类相当于把immutable用作整个声明类型的type constructor：</p> <pre><span>immutable</span> <span>int</span> x = 3;   <span>// x的类型是immutable(int)<br></span><span>immutable</span>(<span>int</span>) y = 3;  <span>// y不可改变<br></span></pre> <h2>创建不变数据</h2> <p>第一种方式：使用本来就不变的字面量（literal），比如字符串字面量。字符串字面量始终都是immutable的。</p> <pre><span>auto</span> s = <span>"hello"</span>;   <span>// s的类型是immutable(char)[5]<br></span><span>char</span>[] p = <span>"world"</span>; <span>// 错误，immutable类型不能隐式转换为非immutable类型。<br></span></pre> <p>第二种方式是把数据转换为immutable。这样做时，需要由程序员确保不存在其他的对该块数据的可变引用。</p> <pre><span>char</span>[] s = ...;<br><span>immutable</span>(<span>char</span>)[] p = <span>cast</span>(<span>immutable</span>)s;     <span>// 未定义行为<br></span><span>immutable</span>(<span>char</span>)[] p = <span>cast</span>(<span>immutable</span>)s.dup; <span>// 正确，只存在一个引用<br></span></pre> <p>使用<tt>.idup</tt>属性，可以便利的创建某个数组的不变副本。</p> <pre><span>auto</span> p = s.idup;<br>p[0] = ...;   <span>// 错误，p[]不可改变<br></span></pre> <h2>通过转换移除immutable</h2> <p>immutable类型可通过强制转换而被移除。</p> <pre><span>immutable</span> <span>int</span>* p = ...;<br><span>int</span>* q = <span>cast</span>(<span>int</span>*)p;<br></pre> <p>不过，这并不意味着可以修改这块数据。</p> <pre>*q = 3; <span>// 编译通过，但结果会导致未定义行为<br></span></pre> <p>在有些情况下，强制抹除不变性是必要的。比如涉及某个不能更改的库，而库中的静态类型并不正确。有史以来，强制转换一直很直接很有效。使用强制转换抹除不变性时，必须要承担保证数据不变的责任，因为它已经不再由编译器静态保证了。</p> <h2>immutable成员函数</h2> <p>immutable成员函数表示<tt>this</tt>以及被<tt>this</tt>引用的任何数据都是不变的。可以这样声明： </p> <pre><span>struct</span> S<br>{   <span>int</span> x;<br><br>    <span>immutable</span> <span>void</span> foo()<br>    {<br> x = 4;     <span>// 错误，x不可改变<br></span> <span>this</span>.x = 4; <span>// 错误，x不可改变<br></span>    }<br></pre> <p>函数的<span>const</span>和<span>immutable</span>属性也可以写在参数列表的右括号之后：</p> <pre><span>struct</span> S<br>{<br>    <span>void</span> bar() <span>immutable</span><br>    {<br>    }<br>}<br></pre> <h2>const类型</h2> <p>const类型和immutable类型类似，唯一的区别在于const建立的是数据的只读<i>视图</i>。数据本身随时可能被其他引用了该数据的变量所修改。</p> <h2>const成员函数</h2> <p>在const成员函数中，不允许通过该函数的this指针改变对象任何部分的数据。</p> <h2>隐式转换</h2> <p>immutable和非immutable类型都可以隐式转换为const类型。非immutable类型不能隐式转换为immutable类型，反之亦然。</p> <h2>对比D和C++的immutable/const</h2>  <table border="2" cellpadding="4" cellspacing="0"><caption>Const, Immutable Comparison</caption> <thead> <tr> <th>特性</th> <th>D</th> <th>C++98</th> </tr> </thead> <tbody> <tr> <td>const关键字</td> <td>有</td> <td>有</td> </tr> <tr> <td>immutable关键字</td> <td>有</td> <td>无</td> </tr> <tr> <td>const表示方式</td> <td>函数式：<pre><span>//指向指向const int的const指针的指针<br></span><span>const</span>(<span>int</span>*)* p;<br></pre> </td> <td>后缀：<pre>//指向指向const int的const指针的指针<br>const int *const *p;<br></pre> </td> </tr> <tr> <td>有传递性的const</td> <td>有：<pre><span>//指向指向const int的const指针的const指针<br></span><span>const</span> <span>int</span>** p;<br>**p = 3; <span>// 错误<br></span></pre> </td> <td>无：<pre>//指向指向int的指针的const指针<br>int** const p;<br>**p = 3;    // 通过<br></pre> </td> </tr> <tr> <td>强制抹除const</td> <td>有：<pre><span>// 指向const int的指针<br></span><span>const</span>(<span>int</span>)* p;<br><span>int</span>* q = <span>cast</span>(<span>int</span>*)p; <span>// ok<br></span></pre> </td> <td>有：<pre>// 指向const int的指针<br><br>const int* p;<br>int* q = const_cast&lt;int*&gt;p; //ok<br></pre> </td> </tr> <tr> <td>强制抹除const后进行修改</td> <td>无：<pre><span>// 指向const int的指针<br></span><span>const</span>(<span>int</span>)* p;<br><span>int</span>* q = <span>cast</span>(<span>int</span>*)p;<br>*q = 3;   <span>// 未定义行为<br></span></pre> </td> <td>有：<pre>// 指向const int的指针<br>const int* p;<br>int* q = const_cast&lt;int*&gt;p;<br>*q = 3;   // 通过<br></pre> </td> </tr> <tr> <td>以顶级const区分重载的函数</td> <td>有：<pre><span>void</span> foo(<span>int</span> x);<br><span>void</span> foo(<span>const</span> <span>int</span> x);  <span>//正确<br></span></pre> </td> <td>无：<pre>void foo(int x);<br>void foo(const int x);  //错误<br></pre> </td> </tr> <tr> <td>变量的const别名</td> <td>有：<pre><span>void</span> foo(<span>const</span> <span>int</span>* x, <span>int</span>* y)<br>{<br>   bar(*x); <span>// bar(3)<br></span>   *y = 4;<br>   bar(*x); <span>// bar(4)<br></span>}<br>...<br><span>int</span> i = 3;<br>foo(&amp;i, &amp;i);<br></pre> </td> <td>有：<pre>void foo(const int* x, int* y)<br>{<br>   bar(*x); // bar(3)<br>   *y = 4;<br>   bar(*x); // bar(4)<br>}<br>...<br>int i = 3;<br>foo(&amp;i, &amp;i);<br></pre> </td> </tr> <tr> <td>变量的immutable别名</td> <td>无：<pre><span>void</span> foo(<span>immutable</span> <span>int</span>* x, <span>int</span>* y)<br>{<br>   bar(*x); <span>// bar(3)<br></span>   *y = 4;  <span>// 未定义行为<br></span>   bar(*x); <span>// bar(??)<br></span>}<br>...<br><span>int</span> i = 3;<br>foo(<span>cast</span>(<span>immutable</span>)&amp;i, &amp;i);<br></pre> </td> <td>没有immutable</td> </tr> <tr> <td>字符串字面量的类型</td> <td>immutable(char)[]</td> <td>const char*</td> </tr> <tr> <td>将字符串字面量转换为非常量</td> <td>不允许</td> <td>允许但不推荐</td></tr></tbody></table></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200971294550714</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200971294550714</guid>
    <pubDate>Wed, 12 Aug 2009 09:45:50 +0800</pubDate>
    <dcterms:modified>2009-08-12T09:45:50+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[用gimp脚本批量转换TGA到PNG]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/136490562009754623756</link>
    <description><![CDATA[<div>本来在Windows里面用ACDSee批量转格式的，结果发现用ACDSee把TGA转到PNG之后，透明通道都丢失了。<br>没办法，只好到Linux里面用gimp脚本来转。gimp的脚本得用Scheme写，gimp里面就能找到gimp的API。不过我没用过Scheme，不知道Scheme有些啥库函数能遍历文件系统的，所以绕了个圈子，用Shell脚本遍历文件，再把文件名硬编码到Scheme脚本中：<pre>#!/bin/bash<br>(<br> find .  -iname '*.TGA' -exec echo '<br>  (let ((image (car (file-tga-load 1 "{}" "{}"))))<br>   (file-png-save-defaults 1 image (car (gimp-image-get-active-drawable image)) "{}.png" "{}.png")<br>   (gimp-image-delete image)<br>  )<br> ' \;<br> echo '(gimp-quit 1)'<br>) | gimp-console -d -i -b -<br></pre></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/136490562009754623756</comments>
    <slash:comments>0</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/136490562009754623756</guid>
    <pubDate>Wed, 5 Aug 2009 16:06:23 +0800</pubDate>
    <dcterms:modified>2009-08-05T16:06:23+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[朋友们大家好]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200962231357829</link>
    <description><![CDATA[<div>我日志上写的东西都是些自说自话，有点想法就记下来，没有怎么考虑读者。不过我在Google Reader上也看到有30个人订阅了我的日志，不由得产生好奇，到底上这儿来的朋友都是做什么的，怎么找到这儿来的，对哪方面的文章感兴趣？以后也可以多交流交流嘛。<br></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200962231357829</comments>
    <slash:comments>3</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200962231357829</guid>
    <pubDate>Wed, 22 Jul 2009 15:13:57 +0800</pubDate>
    <dcterms:modified>2009-07-22T15:13:57+08:00</dcterms:modified>
  </item>    
  <item>
  	<title><![CDATA[Scala 2.8预览：Continuation]]></title>	
    <link>http://www.ac.net.blog.163.com/blog/static/13649056200962163123535</link>
    <description><![CDATA[<div><span><a href="http://www.scala-lang.org/node/2096">英文原文</a>由 rompf 发表于 2009年6月5日。</span><div><span></span><p>Scala 2.8将支持一种强大的逻辑流程抽象功能――<a href="http://en.wikipedia.org/wiki/Continuation">continuation</a>。它最牛逼之处在于允许你直接以逐语句风格使用基于回调、事件驱动的API。</p><p>这将能简化许多编程任务：</p><ul><li>使用Java NIO处理异步I/O</li><li>使用Executor和线程池</li><li>在Web应用中处理跨越多个请求的逻辑流程</li></ul><p>在Scala 2.8中并不会专门为以上用例引入新的API。相反，我们期待，当底层的 Continuation 机制加入之时，你会自然而然的用上它。</p> <p>&nbsp;</p><h2>概览Shift和Reset</h2><p>Continuation可在某一时刻对程序进行“捕获”得到，它包含了这一时刻该程序的“其余部分”。Continuation有一点很有意思，它可以被视为普通的函数变量，比如你可以把它保存在数据结构中，然后再进行一次或多次调用（也可以根本不调用它）。Scala中的Continuation和
Schememe或ML中的不同，Scala中的Continuation具有隔离范围（即composable或delimited）。这意味着，它们并不包含程序的全部剩余部分，而只包含由程序员定义的范围内的剩余部分。</p><p>可以使用<em>shift</em>和<em>reset</em>两个基本方法操作Continuation。调用<em>shift</em>能捕获当前Continuation，而<em>reset</em>界定了Continuation能到达的边界。下面是一段示例：</p><pre>reset {<br>  ...<br>  shift { k: (Int=&gt;Int) =&gt;  // the continuation k will be the '_ + 1' below<br>    k(7)<br>  } + 1<br>}<br>// result: 8<br><br></pre><p>当然，<em>shift</em>和<em>reset</em>是库函数，而不是新的关键字。从语法角度看，这二者亦无需同时出现。事实上，对<em>shift</em>和<em>reset</em>的使用中可以出现在完全无关的方法中。类型系统能确保不出差错，并要求每一个包含<em>shift</em>方法都在其返回类型标记了<em>@cps</em>类型注释（type annotation）。许多情况下，该类型注释会被自动推断，无须程序员过问。</p><pre>def foo(): Int @cps[Int,Int] = { // could leave out return type<br>  shift { k: (Int=&gt;Int) =&gt;<br>    k(7)<br>  } + 1<br>}<br>reset(2 * foo()) // result: 16</pre><p>以下是另一示例，示范了如何在基于回调的API使用Continuation.</p><pre>imp<wbr>ort java.util.{Timer,TimerTask}<br><br>val timer = new Timer()<br><br>def sleep(delay: Int) = shift { k: (Unit =&gt; Unit) =&gt;<br>  timer.schedule(new TimerTask {<br>    def run() = k() // in a real program, we'd execute k on a thread pool<br>  }, delay)<br>}<br><br>println("look, Ma ...")<br>sleep(1000)<br>println(" no threads!")<br><br><br></pre><p>如果您想先睹为快，自己动手试试Scala编译器的Continuation插件预发布版吧（可从<a href="http://lampsvn.epfl.ch/svn-repos/scala/compiler-plugins/continuations/">源代码版本库</a>中获取）。若要了解Scala 2.8实现Continuation的相关细节，请看相应的<a href="http://lamp.epfl.ch/%7Erompf/continuations-icfp09.pdf">文件</a> （ICFP'09中加入） 。</p>
</div></div>]]></description>
	    <author><![CDATA[Atry]]></author>
	    <comments>http://www.ac.net.blog.163.com/blog/static/13649056200962163123535</comments>
    <slash:comments>2</slash:comments>
    <guid isPermaLink="true">http://www.ac.net.blog.163.com/blog/static/13649056200962163123535</guid>
    <pubDate>Tue, 21 Jul 2009 18:31:23 +0800</pubDate>
    <dcterms:modified>2009-07-21T18:31:23+08:00</dcterms:modified>
  </item>    
 </channel>
</rss>